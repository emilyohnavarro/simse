/*
 * This class is responsible for generating all of the code for the logic's
 * MiscUpdater component, which is responsible for doing various updating tasks
 * like clearing employee menus and overhead texts, and incrementing action
 * times
 */

package simse.codegenerator.logicgenerator;

import simse.codegenerator.CodeGeneratorConstants;
import simse.codegenerator.CodeGeneratorUtils;

import simse.modelbuilder.actionbuilder.ActionType;
import simse.modelbuilder.actionbuilder.ActionTypeDestroyer;
import simse.modelbuilder.actionbuilder.DefinedActionTypes;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import java.util.Vector;

import javax.swing.JOptionPane;

public class MiscUpdaterGenerator implements CodeGeneratorConstants {
  private File directory; // directory to generate into
  private File muFile; // file to generate
  private DefinedActionTypes actTypes;

  public MiscUpdaterGenerator(File directory, DefinedActionTypes actTypes) {
    this.directory = directory;
    this.actTypes = actTypes;
  }

  public void generate() {
    try {
      muFile = new File(directory, ("simse\\logic\\MiscUpdater.java"));
      if (muFile.exists()) {
        muFile.delete(); // delete old version of file
      }
      FileWriter writer = new FileWriter(muFile);
      writer
          .write("/* File generated by: simse.codegenerator.logicgenerator.MiscUpdaterGenerator */");
      writer.write(NEWLINE);
      writer.write("package simse.logic;");
      writer.write(NEWLINE);
      writer.write("import simse.state.*;");
      writer.write(NEWLINE);
      writer.write("import simse.adts.objects.*;");
      writer.write(NEWLINE);
      writer.write("import simse.adts.actions.*;");
      writer.write(NEWLINE);
      writer.write("import java.util.*;");
      writer.write(NEWLINE);
      writer.write("public class MiscUpdater");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("private State state;");
      writer.write(NEWLINE);
      writer.write("public MiscUpdater(State s)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("state = s;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("public void update()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("// clear menus and overhead texts:");
      writer.write(NEWLINE);
      writer
          .write("Vector<Employee> employees = state.getEmployeeStateRepository().getAll();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<employees.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("employees.elementAt(i).clearOverheadText();");
      writer.write(NEWLINE);
      writer.write("employees.elementAt(i).clearMenu();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// update actions' time elapsed:");
      writer.write(NEWLINE);
      writer
          .write("Vector<simse.adts.actions.Action> actions = state.getActionStateRepository().getAllActions();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<actions.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("simse.adts.actions.Action act = actions.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("act.incrementTimeElapsed();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// decrement time to live for actions w/ timed destroyers:");
      writer.write(NEWLINE);
      Vector<ActionType> allActions = actTypes.getAllActionTypes();
      // make a vector w/ all action types that have timed destroyers:
      Vector<ActionType> timedActs = new Vector<ActionType>();
      for (int i = 0; i < allActions.size(); i++) {
        ActionType act = allActions.elementAt(i);
        if (act.hasDestroyerOfType(ActionTypeDestroyer.TIMED)) {
          timedActs.add(act);
        }
      }
      
      // generate code for action types w/ timed destroyers:
      for (int i = 0; i < timedActs.size(); i++) {
        ActionType act = timedActs.elementAt(i);
        writer.write("Vector<" + 
        		CodeGeneratorUtils.getUpperCaseLeading(act.getName()) + "Action>" + 
        		act.getName().toLowerCase() + 
        		"Actions = state.getActionStateRepository().get" + 
        		CodeGeneratorUtils.getUpperCaseLeading(act.getName()) + 
        		"ActionStateRepository().getAllActions();");
        writer.write(NEWLINE);
        writer.write("for (int i = 0; i < " + act.getName().toLowerCase() + 
        		"Actions.size(); i++) {");
        writer.write(NEWLINE);
        writer.write(CodeGeneratorUtils.getUpperCaseLeading(act.getName()) + 
        		"Action act = " +
        		act.getName().toLowerCase() + "Actions.elementAt(i);");
        writer.write(NEWLINE);
        writer.write("act.decrementTimeToLive();");
        writer.write(NEWLINE);
        writer.write(CLOSED_BRACK);
        writer.write(NEWLINE);
      }
      writer.write(NEWLINE);
      writer.write("// update clock:");
      writer.write(NEWLINE);
      writer.write("state.getClock().incrementTime();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.close();
    } catch (IOException e) {
      JOptionPane.showMessageDialog(null, ("Error writing file "
          + muFile.getPath() + ": " + e.toString()), "File IO Error",
          JOptionPane.WARNING_MESSAGE);
    }
  }
}