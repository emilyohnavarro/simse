/*
 * This class is responsible for generating all of the code for the World class
 * for the GUI
 */

package simse.codegenerator.guigenerator;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import javax.swing.JOptionPane;;

public class WorldGenerator {
  private final char NEWLINE = '\n';
  private final char OPEN_BRACK = '{';
  private final char CLOSED_BRACK = '}';

  private File directory; // directory to save generated code into

  public WorldGenerator(File directory) {
    this.directory = directory;
  }

  public void generate() {
    File worldFile = new File(directory, ("simse\\gui\\World.java"));
    if (worldFile.exists()) {
      worldFile.delete(); // delete old version of file
    }
    try {
      FileWriter writer = new FileWriter(worldFile);
      writer
          .write("/* File generated by: simse.codegenerator.guigenerator.WorldGenerator */");
      writer.write(NEWLINE);
      writer.write("package simse.gui;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("import simse.adts.objects.*;");
      writer.write(NEWLINE);
      writer.write("import simse.state.*;");
      writer.write(NEWLINE);
      writer.write("import simse.logic.*;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("import java.awt.event.*;");
      writer.write(NEWLINE);
      writer.write("import java.awt.*;");
      writer.write(NEWLINE);
      ;
      writer.write("import javax.swing.*;");
      writer.write(NEWLINE);
      writer.write("import java.util.*;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("public class World extends SimSEMap implements KeyListener, MouseListener, ActionListener");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);

      // member variables:
      writer.write("private int clickedHeightModifier = 5;");
      writer.write(NEWLINE);
      writer.write("private int clickedX;");
      writer.write(NEWLINE);
      writer.write("private int clickedY;");
      writer.write(NEWLINE);
      writer.write("public final int xViewable = 9;");
      writer.write(NEWLINE);
      writer.write("public final int yViewable = 9;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("private final SimSEGUI mainGUIFrame;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// used in drawing the speech bubble:");
      writer.write(NEWLINE);
      writer.write("public static final int FREE = 0;");
      writer.write(NEWLINE);
      writer.write("public static final int LEFT = -1;");
      writer.write(NEWLINE);
      writer.write("public static final int RIGHT = 1;");
      writer.write(NEWLINE);
      writer.write("public static final int TOP = -1;");
      writer.write(NEWLINE);
      writer.write("public static final int BOTTOM = 1;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("private boolean overheadTextDisplayed; // whether or not there is overhead text to display");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("private JPopupMenu popup;");
      writer.write(NEWLINE);
      writer.write("private PopupListener popupListener;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("private DisplayedEmployee selectedUser;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("// how much to shift the map when a resize of the screen occurs:");
      writer.write(NEWLINE);
      writer.write("private int xspacer;");
      writer.write(NEWLINE);
      writer.write("private int yspacer;");
      writer.write(NEWLINE);
      writer.write("private boolean employeeGone = false;");
      writer.write(NEWLINE);
      writer.write("private Image dbImage;");
      writer.write(NEWLINE);
      writer.write("private Graphics dbGraphics;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // constructor:
      writer.write("public World(State s, Logic l, SimSEGUI parent)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("super(s, l);");
      writer.write(NEWLINE);
      writer.write("mainGUIFrame = parent;");
      writer.write(NEWLINE);
      writer.write("overheadTextDisplayed = false;");
      writer.write(NEWLINE);
      writer.write("loadDefaultSettings();");
      writer.write(NEWLINE);
      writer.write("update();");
      writer.write(NEWLINE);
      writer.write("validate();");
      writer.write(NEWLINE);
      writer.write("repaint();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // loadDefaultSettings function:
      writer.write("private void loadDefaultSettings()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("selectedUser = null;");
      writer.write(NEWLINE);
      writer.write("setBackground(Color.blue);");
      writer.write(NEWLINE);
      writer.write("addKeyListener(this);");
      writer.write(NEWLINE);
      writer.write("addMouseListener(this);");
      writer.write(NEWLINE);
      writer.write("setVisible(true);");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// right click menu:");
      writer.write(NEWLINE);
      writer.write("popup = new JPopupMenu();");
      writer.write(NEWLINE);
      writer.write("popupListener = new PopupListener(popup,mainGUIFrame);");
      writer.write(NEWLINE);
      writer.write("popupListener.setEnabled(false);");
      writer.write(NEWLINE);
      writer.write("createPopupMenu();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // overheadTextDisplayed function:
      writer
          .write("public boolean overheadTextDisplayed() // returns true if there is overhead text displayed, false otherwise");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("return overheadTextDisplayed;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // createPopupMenu function:
      writer.write("public void createPopupMenu()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("popup.removeAll();");
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      /*
       * writer.write("if(mainGUIFrame.getEngine().isRunning())");
       * writer.write(NEWLINE); writer.write(OPEN_BRACK); writer.write(NEWLINE);
       * writer.write("return;"); writer.write(NEWLINE);
       * writer.write(CLOSED_BRACK);
       */
      writer.write(NEWLINE);

      writer.write(NEWLINE);
      writer.write("if(selectedUser != null)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Vector<String> menuItems = selectedUser.getEmployee().getMenu();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<menuItems.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("String item = menuItems.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("JMenuItem tempItem = new JMenuItem(item);");
      writer.write(NEWLINE);
      writer.write("tempItem.addActionListener(this);");
      writer.write(NEWLINE);
      writer.write("popup.add(tempItem);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("addMouseListener(popupListener);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // update(Graphics g) function:
      writer.write("// double buffering to prevent flickering");
      writer.write(NEWLINE);
      writer.write("public void update (Graphics g)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("if (dbImage == null)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("dbImage = createImage(getSize().width, getSize().height);");
      writer.write(NEWLINE);
      writer.write("dbGraphics = dbImage.getGraphics();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// clear screen in background:");
      writer.write(NEWLINE);
      writer.write("dbGraphics.setColor(Color.BLACK);");
      writer.write(NEWLINE);
      writer
          .write("dbGraphics.fillRect (0, 0, getSize().width, getSize().height);");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// draw elements in background:");
      writer.write(NEWLINE);
      writer.write("paint(dbGraphics);");
      writer.write(NEWLINE);
      writer.write("// draw image on the screen:");
      writer.write(NEWLINE);
      writer.write("g.drawImage (dbImage, 0, 0, this);");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("if (employeeGone) // employee is about to disappear, need to sleep thread so the user can see their overhead text before they disappear");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("try");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Thread.sleep(1000);");
      writer.write(NEWLINE);
      writer.write("employeeGone = false;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("catch(InterruptedException e)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("System.out.println(e.toString());");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // paint function:
      writer.write("public void paint(Graphics g)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Dimension d = getSize();");
      writer.write(NEWLINE);
      writer.write("int width = (int)d.getWidth();");
      writer.write(NEWLINE);
      writer.write("int height = (int)d.getHeight();");
      writer.write(NEWLINE);
      writer.write("g.fillRect(0,0,	width,height);");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("xspacer = (width - MapData.X_MAPSIZE *MapData.TILE_SIZE ) / 2;");
      writer.write(NEWLINE);
      writer
          .write("yspacer = (height - MapData.Y_MAPSIZE *MapData.TILE_SIZE ) / 2;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("if (xspacer < 0)");
      writer.write(NEWLINE);
      writer.write("xspacer = 0;");
      writer.write(NEWLINE);
      writer.write("if (yspacer < 0)");
      writer.write(NEWLINE);
      writer.write("yspacer = 0;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      writer.write("// draw the map:");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<MapData.Y_MAPSIZE; i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("for(int j=0; j<MapData.X_MAPSIZE; j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("g.drawImage(mapRep[j][i].getBase(), xspacer + j * MapData.TILE_SIZE, yspacer + i * MapData.TILE_SIZE, this);");
      writer.write(NEWLINE);
      writer
          .write("g.drawImage(mapRep[j][i].getFringe(), xspacer + j * MapData.TILE_SIZE, yspacer + i * MapData.TILE_SIZE, this);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// draw employees:");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<sopUsers.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tmp = sopUsers.get(i);");
      writer.write(NEWLINE);
      writer.write("if(tmp.isDisplayed() && tmp.isActivated())");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("g.drawImage(tmp.getUserIcon(), xspacer + tmp.getXLocation() * MapData.TILE_SIZE, yspacer + tmp.getYLocation() * MapData.TILE_SIZE, this);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("// go through all employees and display their overhead text, if any:");
      writer.write(NEWLINE);
      writer.write("int numOverheadTexts = 0;");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<sopUsers.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tempEmp = sopUsers.get(i);");
      writer.write(NEWLINE);
      writer
          .write("String overheadText = tempEmp.getEmployee().getOverheadText();");
      writer.write(NEWLINE);
      writer
          .write("if((overheadText != null) && (overheadText.length() > 0)) // employee has overhead text");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("numOverheadTexts++;");
      writer.write(NEWLINE);
      writer
          .write("drawText(overheadText, tempEmp.getXLocation(), tempEmp.getYLocation(), g);");
      writer.write(NEWLINE);
      writer
          .write("if(state.getEmployeeStateRepository().getAll().contains(tempEmp.getEmployee()) == false) // employee is about to disappear");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("employeeGone = true;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("if(numOverheadTexts > 0)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("overheadTextDisplayed = true;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("else // no overhead text to display");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("overheadTextDisplayed = false;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("ArrayList<DisplayedEmployee> oldSopUsers = new ArrayList<DisplayedEmployee>(sopUsers);");
      writer.write(NEWLINE);
      writer.write("sopUsers.clear();");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("// go through sop users and make sure that they are still in the state (haven't been destroyed):");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<oldSopUsers.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tempDisEmp = oldSopUsers.get(i);");
      writer.write(NEWLINE);
      writer
          .write("if(state.getEmployeeStateRepository().getAll().contains(tempDisEmp.getEmployee())) // employee is still there");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("sopUsers.add(tempDisEmp);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("// check if any new emps have been added:");
      writer.write(NEWLINE);
      writer
          .write("if(sopUsers.size() < state.getEmployeeStateRepository().getAll().size()) // new emps have been added");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("Vector<Employee> allEmps = state.getEmployeeStateRepository().getAll();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<allEmps.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Employee tempEmp = allEmps.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("boolean newEmp = true;");
      writer.write(NEWLINE);
      writer.write("for(int j=0; j<sopUsers.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tempDisEmp = sopUsers.get(j);");
      writer.write(NEWLINE);
      writer.write("if(tempDisEmp.getEmployee().equals(tempEmp))");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("newEmp = false;");
      writer.write(NEWLINE);
      writer.write("break;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("if(newEmp)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("// create new DisplayedEmployee and add to sopUsers:");
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee newDisEmp = new DisplayedEmployee(tempEmp, getImage(tempEmp), this, true, true, getXYCoordinates(tempEmp)[0], getXYCoordinates(tempEmp)[1]);");
      writer.write(NEWLINE);
      writer.write("sopUsers.add(newDisEmp);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // drawText function:
      writer.write("// String s - text to display");
      writer.write(NEWLINE);
      writer
          .write("// int xLoc - x coordinate of the employee to be drawn. -> UserData.xLocation");
      writer.write(NEWLINE);
      writer
          .write("// int yLoc - y coordinate of the employee to be drawn. -> UserData.yLocation");
      writer.write(NEWLINE);
      writer
          .write("// Graphics g - use the graphics object from the paintComponent(Graphics g)");
      writer.write(NEWLINE);
      writer
          .write("public void drawText(String s, int xLoc, int yLoc, Graphics g)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("// do not draw empty strings:");
      writer.write(NEWLINE);
      writer.write("if(s == null || s.equals(\"\"))");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("return;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("// variables for starting x, starting y, width w, height h:");
      writer.write(NEWLINE);
      writer.write("int x = FREE, y = FREE, w = 150, h = 14;");
      writer.write(NEWLINE);
      writer.write("Image speech = MapData.speechTR;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// used to determine how much to shift the bubble:");
      writer.write(NEWLINE);
      writer.write("int xshift, yshift;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// stores the strings");
      writer.write(NEWLINE);
      writer.write("int strlength = s.length() + 1;");
      writer.write(NEWLINE);
      writer.write("int lengthOfOneLine = 28;");
      writer.write(NEWLINE);
      writer.write("int scount = 0, tmpW = 0;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("ArrayList<String> strList = new ArrayList<String>();");
      writer.write(NEWLINE);
      writer.write("FontMetrics f = getFontMetrics(getFont());");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("// if string is longer than <lengthofOneLine> characters, break it into several lines");
      writer.write(NEWLINE);
      writer.write("while (strlength > lengthOfOneLine)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("String temp = s.substring(0, lengthOfOneLine).trim();");
      writer.write(NEWLINE);
      writer.write("int space = temp.lastIndexOf(\" \");");
      writer.write(NEWLINE);
      writer.write("temp = s.substring(0,space);");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("tmpW = f.stringWidth(temp) + 4; // offset of 4 for spacing purposes");
      writer.write(NEWLINE);
      writer.write("if (tmpW > w)");
      writer.write(NEWLINE);
      writer.write("w = tmpW;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("strList.add(temp);");
      writer.write(NEWLINE);
      writer.write("scount++;");
      writer.write(NEWLINE);
      writer.write("s = s.substring(space+1, strlength-1);");
      writer.write(NEWLINE);
      writer.write("strlength = s.length() + 1;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("tmpW = f.stringWidth(s) + 4;");
      writer.write(NEWLINE);
      writer.write("if (tmpW > w)");
      writer.write(NEWLINE);
      writer.write("w = tmpW;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("strList.add(s);		// append either the whole string or the rest of the string");
      writer.write(NEWLINE);
      writer.write("scount++;");
      writer.write(NEWLINE);
      writer
          .write("String[] strings = strList.toArray(new String[1]);");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("h = h + (12 * (scount - 1)); // modify the box to match the string");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("// this checks to determine where you can draw makes sure the speech bubble");
      writer.write(NEWLINE);
      writer.write("// isn't drawn off the map");
      writer.write(NEWLINE);
      writer.write("// 0 - any value, left/right (x)	 or top/bottom  (y)");
      writer.write(NEWLINE);
      writer.write("// 1 - must be either left   (x), 	 top			(y)");
      writer.write(NEWLINE);
      writer.write("// 2 - must be either right  (x),	 bottom			(y)");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// determine which of the 4 types to draw the bubble");
      writer.write(NEWLINE);
      writer.write("if (xLoc < 3)");
      writer.write(NEWLINE);
      writer.write("x = RIGHT; // must be on right side");
      writer.write(NEWLINE);
      writer
          .write("else if (xLoc > xViewable - 3) // may change to visible width of the screen");
      writer.write(NEWLINE);
      writer.write("x = LEFT; // must be on left side");
      writer.write(NEWLINE);
      writer.write("if (yLoc < 1) // can't be top");
      writer.write(NEWLINE);
      writer.write("y = BOTTOM; // must be on bottom");
      writer.write(NEWLINE);
      writer
          .write("if (yLoc > yViewable - 2) // may change to visible height of the screen");
      writer.write(NEWLINE);
      writer.write("y = TOP; // must be on top");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("boolean checkY = true;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("// if x is free check if the bubble may conflict with anyone");
      writer.write(NEWLINE);
      writer.write("if (x == FREE)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("boolean lconflict = false;");
      writer.write(NEWLINE);
      writer.write("int yOffset = y;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("// yOffset may be either top or bottom depending on above if/else block");
      writer.write(NEWLINE);
      writer.write("if (y == FREE)");
      writer.write(NEWLINE);
      writer.write("yOffset = TOP;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("boolean rconflict = false;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// test if it conflicts with top left or bottom left");
      writer.write(NEWLINE);
      writer.write("for (int i = 3; i > 0 && !rconflict; i--)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("for (int j = 0; j < sopUsers.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tmp = sopUsers.get(j);");
      writer.write(NEWLINE);
      writer
          .write("boolean clash = tmp.checkXYLocations(xLoc+i,yLoc+(2*yOffset)) || tmp.checkXYLocations(xLoc+i,yLoc+yOffset) || tmp.checkXYLocations(xLoc+i,yLoc);");
      writer.write(NEWLINE);
      writer.write("if ( clash && tmp.isActivated() )");
      writer.write(NEWLINE);
      //writer.write("if (tmp.checkXYLocations(xLoc+i,yLoc+yOffset) &&
      // tmp.isActivated() )");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("// if a conflict occurs here, it can't be on the right side either");
      writer.write(NEWLINE);
      writer.write("rconflict = true;");
      writer.write(NEWLINE);
      writer.write("x = LEFT;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// can be on right side");
      writer.write(NEWLINE);
      writer.write("if (!rconflict)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("x = RIGHT;");
      writer.write(NEWLINE);
      writer.write("y = yOffset;");
      writer.write(NEWLINE);
      writer.write("checkY = false;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("else	// check the right side");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("// test if it conflicts with top left or bottom left (depending on yOffset)");
      writer.write(NEWLINE);
      writer.write("for (int i = 4; i > 0 && !lconflict; i--)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("for (int j = 0; j < sopUsers.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tmp = sopUsers.get(j);");
      writer.write(NEWLINE);
      writer
          .write("boolean clash = tmp.checkXYLocations(xLoc-i,yLoc+(2*yOffset)) || tmp.checkXYLocations(xLoc-i,yLoc+yOffset) || tmp.checkXYLocations(xLoc-i,yLoc);");
      writer.write(NEWLINE);
      writer.write("if ( clash && tmp.isActivated() )");
      writer.write(NEWLINE);
      //writer.write("if (tmp.checkXYLocations(xLoc-i,yLoc+yOffset) &&
      // tmp.isActivated() )");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("lconflict = true;");
      writer.write(NEWLINE);
      writer.write("x = FREE;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("// doesn't conflict on left side, no need to check other half if y is free");
      writer.write(NEWLINE);
      writer.write("if(!lconflict)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("x = LEFT;");
      writer.write(NEWLINE);
      writer.write("y = yOffset;");
      writer.write(NEWLINE);
      writer.write("checkY = false;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("// same for y if y is free");
      writer.write(NEWLINE);
      writer.write("if (y == FREE && checkY)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("int xOffset = x;");
      writer.write(NEWLINE);
      writer.write("int yOffset = TOP;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("// if x is still free after above check, it means top left and top right");
      writer.write(NEWLINE);
      writer
          .write("// are blocked so on checks left are bottom left and bottom right");
      writer.write(NEWLINE);
      writer.write("if (x == FREE)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("xOffset = LEFT;");
      writer.write(NEWLINE);
      writer.write("yOffset = BOTTOM;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// x is fixed, y is either up or down");
      writer.write(NEWLINE);
      writer.write("if (x == LEFT)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("boolean lconflict = false;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// testing top left / bottom left");
      writer.write(NEWLINE);
      writer.write("for (int i = 4; i > 0 && !lconflict; i--)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("for (int j = 0; j < sopUsers.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tmp = sopUsers.get(j);");
      writer.write(NEWLINE);
      writer
          .write("boolean clash = tmp.checkXYLocations(xLoc-i,yLoc+(2*yOffset)) || tmp.checkXYLocations(xLoc-i,yLoc+yOffset) || tmp.checkXYLocations(xLoc-i,yLoc);");
      writer.write(NEWLINE);
      writer.write("if ( clash && tmp.isActivated() )");
      writer.write(NEWLINE);
      //writer.write("if (tmp.checkXYLocations(xLoc-i,yLoc+yOffset) &&
      // tmp.isActivated() )");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("// if a conflict occurs here, it can't be on the right side either");
      writer.write(NEWLINE);
      writer.write("lconflict = true;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("if(!lconflict)");
      writer.write(NEWLINE);
      writer.write("y = yOffset;");
      writer.write(NEWLINE);
      writer.write("else");
      writer.write(NEWLINE);
      writer.write("y = -yOffset;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("else if (x == RIGHT)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("boolean rconflict = false;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// testing top left / bottom left");
      writer.write(NEWLINE);
      writer.write("for (int i = 3; i > 0 && !rconflict; i--)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("for (int j = 0; j < sopUsers.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tmp = sopUsers.get(j);");
      writer.write(NEWLINE);
      writer
          .write("boolean clash = tmp.checkXYLocations(xLoc+i,yLoc+(2*yOffset)) || tmp.checkXYLocations(xLoc+i,yLoc+yOffset) || tmp.checkXYLocations(xLoc+i,yLoc);");
      writer.write(NEWLINE);
      writer.write("if ( clash && tmp.isActivated() )");
      writer.write(NEWLINE);
      //writer.write("if (tmp.checkXYLocations(xLoc+i,yLoc+yOffset) &&
      // tmp.isActivated() )");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("// if a conflict occurs here, it can't be on the right side either");
      writer.write(NEWLINE);
      writer.write("rconflict = true;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("if(!rconflict)");
      writer.write(NEWLINE);
      writer.write("y = yOffset;");
      writer.write(NEWLINE);
      writer.write("else");
      writer.write(NEWLINE);
      writer.write("y = -yOffset;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer
          .write("else // both x and y are free, so it's either bottom left or bottom right");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("boolean rconflict = false;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// testing top left / bottom left");
      writer.write(NEWLINE);
      writer.write("for (int i = 3; i > 0 && !rconflict; i--)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("for (int j = 0; j < sopUsers.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tmp = sopUsers.get(j);");
      writer.write(NEWLINE);
      writer
          .write("boolean clash = tmp.checkXYLocations(xLoc+i,yLoc+(2*yOffset)) || tmp.checkXYLocations(xLoc+i,yLoc+yOffset) || tmp.checkXYLocations(xLoc+i,yLoc);");
      writer.write(NEWLINE);
      writer.write("if ( clash && tmp.isActivated() )");
      writer.write(NEWLINE);
      //writer.write("if (tmp.checkXYLocations(xLoc+i,yLoc+yOffset) &&
      // tmp.isActivated() )");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("// if a conflict occurs here, it can't be on the right side either");
      writer.write(NEWLINE);
      writer.write("rconflict = true;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("if (!rconflict)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("x = RIGHT;");
      writer.write(NEWLINE);
      writer.write("y = BOTTOM;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("else");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("x = LEFT;");
      writer.write(NEWLINE);
      writer.write("y = BOTTOM;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// determine the speech bubble direction");
      writer.write(NEWLINE);
      writer.write("if (x == LEFT && y == TOP)");
      writer.write(NEWLINE);
      writer.write("speech = MapData.speechTL;");
      writer.write(NEWLINE);
      writer.write("else if (x == RIGHT && y == TOP)");
      writer.write(NEWLINE);
      writer.write("speech = MapData.speechTR;");
      writer.write(NEWLINE);
      writer.write("else if (x == LEFT && y == BOTTOM)");
      writer.write(NEWLINE);
      writer.write("speech = MapData.speechBL;");
      writer.write(NEWLINE);
      writer.write("else if (x == RIGHT && y == BOTTOM)");
      writer.write(NEWLINE);
      writer.write("speech = MapData.speechBR;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// determine where to draw the bubble");
      writer.write(NEWLINE);
      writer.write("// the shifts to x or y are used to place the message");
      writer.write(NEWLINE);
      writer.write("// so that it doesn't completely cover the user object");
      writer.write(NEWLINE);
      writer.write("if ( x == LEFT)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("x = (xLoc-2) * MapData.TILE_SIZE;");
      writer.write(NEWLINE);
      writer.write("xshift = w - 26;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("else");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("x = xLoc * MapData.TILE_SIZE;");
      writer.write(NEWLINE);
      writer.write("xshift = 6;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("if ( y == TOP)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("y = (yLoc - 1) * MapData.TILE_SIZE;");
      writer.write(NEWLINE);
      writer.write("yshift = h;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("else");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("y = (yLoc + 1) * MapData.TILE_SIZE;");
      writer.write(NEWLINE);
      writer.write("yshift = -19;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("x += xspacer;");
      writer.write(NEWLINE);
      writer.write("y += yspacer;");
      writer.write(NEWLINE);
      writer.write("g.setColor(new Color(230,240,255,255));");
      writer.write(NEWLINE);
      writer.write("g.fillRoundRect(x,y,w,h,4,4);");
      writer.write(NEWLINE);
      writer.write("g.setColor(new Color(0,30,110,255));");
      writer.write(NEWLINE);
      writer.write("g.drawRoundRect(x,y,w,h,8,8);");
      writer.write(NEWLINE);
      writer.write("g.drawImage(speech,x+xshift,y+yshift,this);");
      writer.write(NEWLINE);
      writer.write("g.setColor(Color.BLACK);");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("for (int i = 0; i < scount; i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("// space similar to a carriage return add 1 for first line");
      writer.write(NEWLINE);
      writer.write("int yl = 12 * (i + 1) ;");
      writer.write(NEWLINE);
      writer.write("g.drawString(strings[i],x+2,y + yl);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // other functions:
      writer.write("public void keyPressed(KeyEvent e){}");
      writer.write(NEWLINE);
      writer.write("public void keyReleased(KeyEvent e){}");
      writer.write(NEWLINE);
      writer.write("public void keyTyped(KeyEvent e){}");
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // mousePressed function:
      writer.write("public void mousePressed(MouseEvent me)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("// -5 is the offset for the border around the GUI");
      writer.write(NEWLINE);
      writer.write("clickedX = (me.getX() - xspacer - 5)/MapData.TILE_SIZE;");
      writer.write(NEWLINE);
      writer
          .write("clickedY = (me.getY() - yspacer - clickedHeightModifier)/MapData.TILE_SIZE;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("if(me.getButton() == MouseEvent.BUTTON1) // left button clicked");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("for (int i = 0; i < sopUsers.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tmp = sopUsers.get(i);");
      writer.write(NEWLINE);
      writer
          .write("if(tmp.checkXYLocations(clickedX,clickedY) && tmp.isActivated())");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("selectedUser = tmp;");
      writer.write(NEWLINE);
      writer.write("i = sopUsers.size();");
      writer.write(NEWLINE);
      writer.write("mainGUIFrame.getTabPanel().setGUIChanged();");
      writer.write(NEWLINE);
      writer
          .write("mainGUIFrame.getTabPanel().setObjectInFocus(tmp.getEmployee());");
      writer.write(NEWLINE);
      writer.write("mainGUIFrame.getAttributePanel().setGUIChanged();");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("mainGUIFrame.getAttributePanel().setObjectInFocus(tmp.getEmployee(), new ImageIcon(tmp.getUserIcon()));");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("else if(state.getClock().isStopped() == false) // clock not stopped, and not left button click");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("boolean found = false;");
      writer.write(NEWLINE);
      writer.write("for (int i = 0; i < sopUsers.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("DisplayedEmployee tmp = sopUsers.get(i);");
      writer.write(NEWLINE);
      writer
          .write("if (tmp.checkXYLocations(clickedX,clickedY) && tmp.isActivated())");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("selectedUser = tmp;");
      writer.write(NEWLINE);
      writer.write("popupListener.setEnabled(true);");
      writer.write(NEWLINE);
      writer.write("found = true;");
      writer.write(NEWLINE);
      writer.write("i = sopUsers.size();");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("createPopupMenu();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("// did not click on a User object, disable right click");
      writer.write(NEWLINE);
      writer.write("if (!found)");
      writer.write(NEWLINE);
      writer.write("popupListener.setEnabled(false);");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("repaint();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // popupMenuActions function:
      writer.write("public void popupMenuActions(JMenuItem source)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("JMenuItem item = (JMenuItem)source;");
      writer.write(NEWLINE);
      writer
          .write("logic.getMenuInputManager().menuItemSelected(selectedUser.getEmployee(), item.getText(), mainGUIFrame);");
      writer.write(NEWLINE);
      writer.write("update();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // actionPerformed function:
      writer
          .write("public void actionPerformed(ActionEvent e)	// dealing with actions generated by popup menus");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Object source = e.getSource();");
      writer.write(NEWLINE);
      writer.write("if(source instanceof JMenuItem)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("popupMenuActions((JMenuItem)source);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);

      // update function:
      writer.write("public void update()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Graphics g = getGraphics();");
      writer.write(NEWLINE);
      writer.write("if(g != null)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("update(g);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("else");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("repaint();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("if(state.getClock().isStopped())");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("popupListener.setEnabled(false);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);

      writer.write(CLOSED_BRACK);
      writer.close();
    } catch (IOException e) {
      JOptionPane.showMessageDialog(null, ("Error writing file "
          + worldFile.getPath() + ": " + e.toString()), "File IO Error",
          JOptionPane.WARNING_MESSAGE);
    }
  }
}