/*
 * This class is responsible for generating all of the code for the repositories
 * for the ADTs derived from the SimSEObjectTypes in an .sso file
 */

package simse.codegenerator.stategenerator;

import simse.codegenerator.CodeGeneratorConstants;
import simse.codegenerator.CodeGeneratorUtils;

import simse.modelbuilder.ModelOptions;
import simse.modelbuilder.actionbuilder.ActionType;
import simse.modelbuilder.actionbuilder.ActionTypeParticipant;
import simse.modelbuilder.actionbuilder.DefinedActionTypes;
import simse.modelbuilder.objectbuilder.Attribute;
import simse.modelbuilder.objectbuilder.AttributeTypes;
import simse.modelbuilder.objectbuilder.DefinedObjectTypes;
import simse.modelbuilder.objectbuilder.SimSEObjectType;
import simse.modelbuilder.objectbuilder.SimSEObjectTypeTypes;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import java.util.Vector;

import javax.swing.JOptionPane;

public class RepositoryGenerator implements CodeGeneratorConstants {
  private ModelOptions options;
  private DefinedObjectTypes objTypes; // holds all of the defined object types
  private DefinedActionTypes actTypes; // holds all of the defined action types

  public RepositoryGenerator(ModelOptions options, DefinedObjectTypes objTypes, 
      DefinedActionTypes actTypes) {
    this.options = options;
    this.objTypes = objTypes;
    this.actTypes = actTypes;
  }

  public void generate() {
    Vector<SimSEObjectType> objs = objTypes.getAllObjectTypes();
    // go through each object and generate a repository for it:
    for (int i = 0; i < objs.size(); i++) {
      generateObjectRepository(objs.elementAt(i));
    }

    // generate meta-object type repositories:
    generateMetaObjectTypeRepository(SimSEObjectTypeTypes
        .getText(SimSEObjectTypeTypes.EMPLOYEE));
    generateMetaObjectTypeRepository(SimSEObjectTypeTypes
        .getText(SimSEObjectTypeTypes.ARTIFACT));
    generateMetaObjectTypeRepository(SimSEObjectTypeTypes
        .getText(SimSEObjectTypeTypes.TOOL));
    generateMetaObjectTypeRepository(SimSEObjectTypeTypes
        .getText(SimSEObjectTypeTypes.CUSTOMER));
    generateMetaObjectTypeRepository(SimSEObjectTypeTypes
        .getText(SimSEObjectTypeTypes.PROJECT));

    // generate action repositories for each action type:
    Vector<ActionType> acts = actTypes.getAllActionTypes();
    for (int i = 0; i < acts.size(); i++) {
      generateActionRepository(acts.elementAt(i));
    }

    // generate ActionStateRepository:
    File asrFile = new File(options.getCodeGenerationDestinationDirectory(),
        ("simse\\state\\ActionStateRepository.java"));
    if (asrFile.exists()) {
      asrFile.delete(); // delete old version of file
    }
    try {
      FileWriter writer = new FileWriter(asrFile);
      writer
          .write("/* File generated by: simse.codegenerator.stategenerator.RepositoryGenerator */");
      writer.write(NEWLINE);
      writer.write("package simse.state;");
      writer.write(NEWLINE);
      writer.write("import simse.adts.objects.*;");
      writer.write(NEWLINE);
      writer.write("import simse.adts.actions.*;");
      writer.write(NEWLINE);
      writer.write("import java.util.*;");
      writer.write(NEWLINE);
      writer.write("public class ActionStateRepository implements Cloneable");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);

      // member variables:
      for (int i = 0; i < acts.size(); i++) {
        ActionType tempAct = acts.elementAt(i);
        writer.write(CodeGeneratorUtils.getUpperCaseLeading(tempAct.getName())
            + "ActionStateRepository "
            + tempAct.getName().substring(0, 1).toLowerCase() + i + ";");
        writer.write(NEWLINE);
      }
      writer.write(NEWLINE);

      // constructor:
      writer.write("public ActionStateRepository()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      for (int i = 0; i < acts.size(); i++) {
        ActionType tempAct = acts.elementAt(i);
        writer.write(tempAct.getName().substring(0, 1).toLowerCase() + i
            + " = new " + CodeGeneratorUtils.getUpperCaseLeading(
            		tempAct.getName()) + "ActionStateRepository();");
        writer.write(NEWLINE);
      }
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      
      // "clone" method:
      writer.write("public Object clone() {");
      writer.write(NEWLINE);
      writer.write("try {");
      writer.write(NEWLINE);
      writer.write("ActionStateRepository cl = (ActionStateRepository) (super.clone());");
      writer.write(NEWLINE);
      for (int i = 0; i < acts.size(); i++) {
        ActionType tempAct = acts.elementAt(i);
        writer.write("cl." + tempAct.getName().substring(0, 1).toLowerCase() + i
            + " = (" + CodeGeneratorUtils.getUpperCaseLeading(
            		tempAct.getName()) + "ActionStateRepository)(" + 
            		tempAct.getName().substring(0, 1).toLowerCase() + i + 
            		".clone());");
        writer.write(NEWLINE);
      }
      writer.write("return cl;");
      writer.write(NEWLINE);
      writer.write("} catch (CloneNotSupportedException c) {");
      writer.write(NEWLINE);
      writer.write("System.out.println(c.getMessage());");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return null;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "getAllActions" method:
      writer.write("public Vector<simse.adts.actions.Action> getAllActions()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Vector<simse.adts.actions.Action> all = new Vector<simse.adts.actions.Action>();");
      writer.write(NEWLINE);
      for (int i = 0; i < acts.size(); i++) {
        ActionType tempAct = acts.elementAt(i);
        writer.write("all.addAll("
            + tempAct.getName().substring(0, 1).toLowerCase() + i
            + ".getAllActions());");
        writer.write(NEWLINE);
      }
      writer.write("return all;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "getAllActions(SSObject) method:
      writer.write("public Vector<simse.adts.actions.Action> getAllActions(SSObject a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Vector<simse.adts.actions.Action> all = new Vector<simse.adts.actions.Action>();");
      writer.write(NEWLINE);
      writer.write("Vector<simse.adts.actions.Action> actions = getAllActions();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<actions.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Action b = actions.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("Vector<SSObject> parts = b.getAllParticipants();");
      writer.write(NEWLINE);
      writer.write("for(int j=0; j<parts.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("if(parts.elementAt(j).equals(a))");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("all.add(b);");
      writer.write(NEWLINE);
      writer.write("break;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return all;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "getAllActiveActions(SSObject) method:
      writer.write("public Vector<simse.adts.actions.Action> getAllActiveActions(SSObject a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Vector<simse.adts.actions.Action> all = new Vector<simse.adts.actions.Action>();");
      writer.write(NEWLINE);
      writer.write("Vector<simse.adts.actions.Action> actions = getAllActions();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<actions.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Action b = actions.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("Vector<SSObject> parts = b.getAllActiveParticipants();");
      writer.write(NEWLINE);
      writer.write("for(int j=0; j<parts.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("if(parts.elementAt(j).equals(a))");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("all.add(b);");
      writer.write(NEWLINE);
      writer.write("break;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return all;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "getAllInactiveActions(SSObject) method:
      writer.write("public Vector<simse.adts.actions.Action> getAllInactiveActions(SSObject a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Vector<simse.adts.actions.Action> all = new Vector<simse.adts.actions.Action>();");
      writer.write(NEWLINE);
      writer.write("Vector<simse.adts.actions.Action> actions = getAllActions();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<actions.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Action b = actions.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("Vector<SSObject> parts = b.getAllInactiveParticipants();");
      writer.write(NEWLINE);
      writer.write("for(int j=0; j<parts.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("if(parts.elementAt(j).equals(a))");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("all.add(b);");
      writer.write(NEWLINE);
      writer.write("break;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return all;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // removeFromAllActions method:
      writer.write("public void removeFromAllActions(SSObject a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      // go through all action types:
      for (int i = 0; i < acts.size(); i++) {
        ActionType tempAct = acts.elementAt(i);
        String uCaseTempActName = 
        	CodeGeneratorUtils.getUpperCaseLeading(tempAct.getName());
        writer.write("Vector <" + uCaseTempActName + "Action> " + 
        		tempAct.getName().toLowerCase() + "actions = " + 
        		tempAct.getName().substring(0, 1).toLowerCase() + i + 
        		".getAllActions();");
        writer.write(NEWLINE);
        writer.write("for(int i=0; i<" + tempAct.getName().toLowerCase()
            + "actions.size(); i++)");
        writer.write(NEWLINE);
        writer.write(OPEN_BRACK);
        writer.write(NEWLINE);
        writer.write(uCaseTempActName + "Action b = " + 
        		tempAct.getName().toLowerCase() + "actions.elementAt(i);");
        writer.write(NEWLINE);
        // go through all participants:
        Vector<ActionTypeParticipant> participants = 
        	tempAct.getAllParticipants();
        for (int j = 0; j < participants.size(); j++) {
          ActionTypeParticipant part = participants.elementAt(j);
          writer.write("if(a instanceof "
              + SimSEObjectTypeTypes.getText(part.getSimSEObjectTypeType())
              + ")");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          writer.write("b.remove" + part.getName() + "(("
              + SimSEObjectTypeTypes.getText(part.getSimSEObjectTypeType())
              + ")a);");
          writer.write(NEWLINE);
          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);
        }
        writer.write(CLOSED_BRACK);
        writer.write(NEWLINE);
      }
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "get[ActionType]ActionStateRepository" methods:
      for (int i = 0; i < acts.size(); i++) {
        ActionType tempAct = acts.elementAt(i);
        writer.write("public " + CodeGeneratorUtils.getUpperCaseLeading(
        		tempAct.getName()) + "ActionStateRepository get" + 
        		CodeGeneratorUtils.getUpperCaseLeading(tempAct.getName()) + 
        		"ActionStateRepository()");
        writer.write(NEWLINE);
        writer.write(OPEN_BRACK);
        writer.write(NEWLINE);
        writer.write("return "
            + tempAct.getName().substring(0, 1).toLowerCase() + i + ";");
        writer.write(NEWLINE);
        writer.write(CLOSED_BRACK);
        writer.write(NEWLINE);
      }
      writer.write(NEWLINE);
      
      // "getActionWithId" method:
      writer.write("public Action getActionWithId(int id) {");
      writer.write(NEWLINE);
      for (int i =0; i < acts.size(); i++) {
        ActionType tempAct = acts.get(i);
        if (i > 0) {
          writer.write("else ");
        }
        writer.write("if (" + tempAct.getName().substring(0, 1).toLowerCase()
            + i + ".getActionWithId(id) != null) {");
        writer.write(NEWLINE);
        writer.write("return " + tempAct.getName().substring(0, 1).toLowerCase()
            + i + ".getActionWithId(id);");
        writer.write(NEWLINE);
        writer.write(CLOSED_BRACK);
        writer.write(NEWLINE);
      }
      writer.write("return null;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      
      // refetchParticipants method:
    	writer.write("/*");
    	writer.write(NEWLINE);
    	writer.write("* Replaces all the participants in each action with their equivalent objects");
    	writer.write(NEWLINE);
    	writer.write("* in the current state. Calling this function solves the problem that");
    	writer.write(NEWLINE);
    	writer.write("* happens when you clone actions -- their hashtables point to participant");
    	writer.write(NEWLINE);
    	writer.write("* objects that were part of the previous, non-cloned state.");
    	writer.write(NEWLINE);
    	writer.write("* Hence, this function should be called after this object is cloned.");
    	writer.write(NEWLINE);
    	writer.write("*/");
    	writer.write(NEWLINE);
    	writer.write("public void refetchParticipants(ArtifactStateRepository artifactRep, CustomerStateRepository customerRep, EmployeeStateRepository employeeRep, ProjectStateRepository projectRep, ToolStateRepository toolRep) {");
    	writer.write(NEWLINE);
      for (int i = 0; i < acts.size(); i++) {
        ActionType tempAct = acts.elementAt(i);
        writer.write(tempAct.getName().substring(0, 1).toLowerCase() + i +
        		".refetchParticipants(artifactRep, customerRep, employeeRep, " +
        		"projectRep, toolRep);");
        writer.write(NEWLINE);
      }
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      
      writer.write(CLOSED_BRACK);
      writer.close();
    } catch (IOException e) {
      JOptionPane.showMessageDialog(null, ("Error writing file "
          + asrFile.getPath() + ": " + e.toString()), "File IO Error",
          JOptionPane.WARNING_MESSAGE);
    }
  }

  private void generateObjectRepository(SimSEObjectType objType) {
    String uCaseName = CodeGeneratorUtils.getUpperCaseLeading(
    		objType.getName());
    String lCaseName = objType.getName().toLowerCase();
    File repFile = new File(options.getCodeGenerationDestinationDirectory(), 
        ("simse\\state\\" + uCaseName + "StateRepository.java"));
    if (repFile.exists()) {
      repFile.delete(); // delete old version of file
    }
    try {
      FileWriter writer = new FileWriter(repFile);
      writer
          .write("/* File generated by: simse.codegenerator.stategenerator.RepositoryGenerator */");
      writer.write(NEWLINE);
      writer.write("package simse.state;");
      writer.write(NEWLINE);
      writer.write("import simse.adts.objects.*;");
      writer.write(NEWLINE);
      writer.write("import java.util.*;");
      writer.write(NEWLINE);
      writer.write("public class " + uCaseName + 
          "StateRepository implements Cloneable");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);

      // member variables:
      writer.write("private Vector <" + uCaseName + "> " + lCaseName + "s;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // constructor:
      writer.write("public " + uCaseName + "StateRepository()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write(lCaseName + "s = new Vector<" + uCaseName + ">();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      
      // "clone" method:
      writer.write("public Object clone() {");
      writer.write(NEWLINE);
      writer.write("try {");
      writer.write(NEWLINE);
      writer.write(uCaseName + "StateRepository cl = (" + uCaseName + 
          "StateRepository) super.clone();");
      writer.write(NEWLINE);
      writer.write("Vector<" + uCaseName + "> cloned" + lCaseName + 
      		"s = new Vector<" + uCaseName + ">();");
      writer.write(NEWLINE);
      writer.write("for (int i = 0; i < " + lCaseName + "s.size(); i++) {");
      writer.write(NEWLINE);
      writer.write("cloned" + lCaseName + "s.addElement((" + uCaseName + 
          ")(" + lCaseName + 
          "s.elementAt(i).clone()));");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("cl." + lCaseName + "s = cloned" + lCaseName + "s;");
      writer.write(NEWLINE);
      writer.write("return cl;");
      writer.write(NEWLINE);
      writer.write("} catch (CloneNotSupportedException c) {");
      writer.write(NEWLINE);
      writer.write("System.out.println(c.getMessage());");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return null;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "add" method:
      writer.write("public void add(" + CodeGeneratorUtils.getUpperCaseLeading(
      		objType.getName()) + " a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("boolean add = true;");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<" + objType.getName().toLowerCase()
          + "s.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write(CodeGeneratorUtils.getUpperCaseLeading(objType.getName()) + 
      		" " + objType.getName().toLowerCase() + " = " +
      		objType.getName().toLowerCase() + "s.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("if(" + objType.getName().toLowerCase() + ".get"
          + CodeGeneratorUtils.getUpperCaseLeading(objType.getKey().getName()) +
          "()");
      if (objType.getKey().getType() == AttributeTypes.STRING) { // string key
                                                                 // attribute
        writer.write(".equals(");
      } else { // boolean or numerical key attribute
        writer.write(" == ");
      }
      writer.write("a.get" + CodeGeneratorUtils.getUpperCaseLeading(
      		objType.getKey().getName()) + "())");
      if (objType.getKey().getType() == AttributeTypes.STRING) {
        // add the extra (
        writer.write(")");
      }
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("add = false;");
      writer.write(NEWLINE);
      writer.write("break;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("if(add)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write(objType.getName().toLowerCase() + "s.add(a);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "get" method:
      Attribute keyAtt = objType.getKey();
      String attType;
      if (keyAtt.getType() == AttributeTypes.INTEGER) {
        attType = "int";
      } else if (keyAtt.getType() == AttributeTypes.DOUBLE) {
        attType = "double";
      } else if (keyAtt.getType() == AttributeTypes.BOOLEAN) {
        attType = "boolean";
      } else { //(keyAtt.getType() == AttributeTypes.STRING)
        attType = "String";
      }
      writer.write("public " + CodeGeneratorUtils.getUpperCaseLeading(
      		objType.getName()) + " get(" + attType + " " + 
      		keyAtt.getName().toLowerCase() + ")");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<" + objType.getName().toLowerCase()
          + "s.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      if (keyAtt.getType() == AttributeTypes.STRING) { // string key attribute
        writer.write("if(" + objType.getName().toLowerCase() + 
        		"s.elementAt(i).get" + CodeGeneratorUtils.getUpperCaseLeading(
        				keyAtt.getName()) + "().equals(" + 
        				keyAtt.getName().toLowerCase() + "))");
      } else { // int, double, or boolean key attribute
        writer.write("if(" + objType.getName().toLowerCase() + 
        		"s.elementAt(i).get" + CodeGeneratorUtils.getUpperCaseLeading(
        				keyAtt.getName()) + "() == " + keyAtt.getName().toLowerCase() +
        				")");
      }
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("return " + objType.getName().toLowerCase() + 
      		"s.elementAt(i);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return null;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "getAll" method:
      writer.write("public Vector<" + uCaseName + "> getAll()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("return " + objType.getName().toLowerCase() + "s;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "remove" method:
      writer.write("public boolean remove("
          + CodeGeneratorUtils.getUpperCaseLeading(objType.getName()) + " a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("return " + objType.getName().toLowerCase() + "s.remove(a);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);

      writer.write(CLOSED_BRACK);
      writer.close();
    } catch (IOException e) {
      JOptionPane.showMessageDialog(null, ("Error writing file "
          + repFile.getPath() + ": " + e.toString()), "File IO Error",
          JOptionPane.WARNING_MESSAGE);
    }
  }

  private void generateMetaObjectTypeRepository(String typeName) {
    File repFile = new File(options.getCodeGenerationDestinationDirectory(),
        ("simse\\state\\" + typeName + "StateRepository.java"));
    if (repFile.exists()) {
      repFile.delete(); // delete old version of file
    }
    try {
      FileWriter writer = new FileWriter(repFile);
      writer
          .write("/* File generated by: simse.codegenerator.stategenerator.RepositoryGenerator */");
      writer.write(NEWLINE);
      writer.write("package simse.state;");
      writer.write(NEWLINE);
      writer.write("import simse.adts.objects.*;");
      writer.write(NEWLINE);
      writer.write("import java.util.*;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("public class " + typeName + 
      		"StateRepository implements Cloneable");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);

      // member variables:
      Vector<SimSEObjectType> objs = 
      	objTypes.getAllObjectTypesOfType(
      			SimSEObjectTypeTypes.getIntRepresentation(typeName));
      for (int i = 0; i < objs.size(); i++) {
        SimSEObjectType tempType = objs.elementAt(i);
        writer.write(CodeGeneratorUtils.getUpperCaseLeading(tempType.getName())
            + "StateRepository "
            + tempType.getName().substring(0, 1).toLowerCase() + i + ";");
        writer.write(NEWLINE);
      }
      writer.write(NEWLINE);

      // constructor:
      writer.write("public " + typeName + "StateRepository()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      for (int i = 0; i < objs.size(); i++) {
        SimSEObjectType tempType = objs.elementAt(i);
        writer.write(tempType.getName().substring(0, 1).toLowerCase() + i
            + " = new " + CodeGeneratorUtils.getUpperCaseLeading(
            		tempType.getName()) + "StateRepository();");
        writer.write(NEWLINE);
      }
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      
      // "clone" method:
      writer.write("public Object clone() {");
      writer.write(NEWLINE);
      writer.write("try {");
      writer.write(NEWLINE);
      writer.write(typeName + "StateRepository cl = (" + typeName + 
          "StateRepository) (super.clone());");
      writer.write(NEWLINE);
      for (int i = 0; i < objs.size(); i++) {
        SimSEObjectType tempType = objs.get(i);
        writer.write("cl." + tempType.getName().substring(0, 1).toLowerCase() 
            + i + " = (" + CodeGeneratorUtils.getUpperCaseLeading(
            		tempType.getName()) + "StateRepository)(" + 
            		tempType.getName().substring(0, 1).toLowerCase() + i + 
            		".clone());");
        writer.write(NEWLINE);
      }
      writer.write("return cl;");
      writer.write(NEWLINE);
      writer.write("} catch (CloneNotSupportedException c) {");
      writer.write(NEWLINE);
      writer.write("System.out.println(c.getMessage());");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return null;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "getAll" method:
      writer.write("public Vector<" + typeName + "> getAll()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Vector<" + typeName + "> all = new Vector<" + typeName + 
      		">();");
      writer.write(NEWLINE);
      for (int i = 0; i < objs.size(); i++) {
        SimSEObjectType tempType = objs.elementAt(i);
        writer.write("all.addAll("
            + tempType.getName().substring(0, 1).toLowerCase() + i
            + ".getAll());");
        writer.write(NEWLINE);
      }
      writer.write("return all;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "get[SimSEObjectType]StateRepository" methods:
      for (int i = 0; i < objs.size(); i++) {
        SimSEObjectType tempType = objs.elementAt(i);
        writer.write("public " + CodeGeneratorUtils.getUpperCaseLeading(
        		tempType.getName()) + "StateRepository get" + 
        		CodeGeneratorUtils.getUpperCaseLeading(tempType.getName()) + 
        		"StateRepository()");
        writer.write(NEWLINE);
        writer.write(OPEN_BRACK);
        writer.write(NEWLINE);
        writer.write("return "
            + tempType.getName().substring(0, 1).toLowerCase() + i + ";");
        writer.write(NEWLINE);
        writer.write(CLOSED_BRACK);
        writer.write(NEWLINE);
      }
      writer.write(CLOSED_BRACK);
      writer.close();
    } catch (IOException e) {
      JOptionPane.showMessageDialog(null, ("Error writing file "
          + repFile.getPath() + ": " + e.toString()), "File IO Error",
          JOptionPane.WARNING_MESSAGE);
    }
  }

  private void generateActionRepository(ActionType actType) {
    String uCaseName = CodeGeneratorUtils.getUpperCaseLeading(
    		actType.getName());
    File repFile = new File(options.getCodeGenerationDestinationDirectory(),
        ("simse\\state\\" + uCaseName + "ActionStateRepository.java"));
    if (repFile.exists()) {
      repFile.delete(); // delete old version of file
    }
    try {
      FileWriter writer = new FileWriter(repFile);
      writer
          .write("/* File generated by: simse.codegenerator.stategenerator.RepositoryGenerator */");
      writer.write(NEWLINE);
      writer.write("package simse.state;");
      writer.write(NEWLINE);
      writer.write("import simse.adts.objects.*;");
      writer.write(NEWLINE);
      writer.write("import simse.adts.actions.*;");
      writer.write(NEWLINE);
      writer.write("import java.util.*;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("public class " + uCaseName
          + "ActionStateRepository implements Cloneable");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);

      // member variables:
      writer.write("private Vector<" + uCaseName + "Action> actions;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // constructor:
      writer.write("public " + uCaseName + "ActionStateRepository()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("actions = new Vector<" + uCaseName + "Action>();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      
      // "clone" method:
      writer.write("public Object clone() {");
      writer.write(NEWLINE);
      writer.write("try {");
      writer.write(NEWLINE);
      writer.write(uCaseName + "ActionStateRepository cl = (" + uCaseName +
          "ActionStateRepository) (super.clone());");
      writer.write(NEWLINE);
      writer.write("Vector<" + uCaseName + 
      		"Action> clonedActions = new Vector<" + uCaseName + "Action>();");
      writer.write(NEWLINE);
      writer.write("for (int i = 0; i < actions.size(); i++) {");
      writer.write(NEWLINE);
      writer.write("clonedActions.add((" + uCaseName + 
      		"Action)actions.elementAt(i).clone());");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("cl.actions = clonedActions;");
      writer.write(NEWLINE);
      writer.write("return cl;");
      writer.write(NEWLINE);
      writer.write("} catch (CloneNotSupportedException c) {");
      writer.write(NEWLINE);
      writer.write("System.out.println(c.getMessage());");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return null;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "add" method:
      writer.write("public boolean add("
          + CodeGeneratorUtils.getUpperCaseLeading(actType.getName()) + 
          "Action a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("if(actions.contains(a) == false)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("actions.add(a);");
      writer.write(NEWLINE);
      writer.write("return true;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return false;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "remove" method:
      writer.write("public boolean remove("
          + CodeGeneratorUtils.getUpperCaseLeading(actType.getName()) + 
          "Action a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("if(actions.contains(a))");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("actions.remove(a);");
      writer.write(NEWLINE);
      writer.write("return true;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return false;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "getAllActions()" method:
      writer.write("public Vector<" + uCaseName + "Action> getAllActions()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("return actions;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "getAllActions(object)" method:
      writer.write("public Vector<" + uCaseName + 
      		"Action> getAllActions(SSObject a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Vector<" + uCaseName + "Action> all = new Vector<" + 
      		uCaseName + "Action>();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<actions.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write(CodeGeneratorUtils.getUpperCaseLeading(actType.getName()) + 
      		"Action b = actions.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("Vector<SSObject> parts = b.getAllParticipants();");
      writer.write(NEWLINE);
      writer.write("for(int j=0; j<parts.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("if(parts.elementAt(j).equals(a))");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("all.add(b);");
      writer.write(NEWLINE);
      writer.write("break;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return all;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "getAllActiveActions(object)" method:
      writer.write("public Vector<" + uCaseName + 
      		"Action> getAllActiveActions(SSObject a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Vector<" + uCaseName + "Action> all = new Vector<" + 
      		uCaseName + "Action>();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<actions.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write(CodeGeneratorUtils.getUpperCaseLeading(actType.getName()) + 
      		"Action b = actions.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("Vector<SSObject> parts = b.getAllActiveParticipants();");
      writer.write(NEWLINE);
      writer.write("for(int j=0; j<parts.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("if(parts.elementAt(j).equals(a))");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("all.add(b);");
      writer.write(NEWLINE);
      writer.write("break;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return all;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // "getAllInactiveActions(object)" method:
      writer.write("public Vector<" + uCaseName + 
      		"Action> getAllInactiveActions(SSObject a)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("Vector<" + uCaseName + "Action> all = new Vector<" + 
      		uCaseName + "Action>();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<actions.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write(CodeGeneratorUtils.getUpperCaseLeading(actType.getName()) + 
      		"Action b = actions.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("Vector<SSObject> parts = b.getAllInactiveParticipants();");
      writer.write(NEWLINE);
      writer.write("for(int j=0; j<parts.size(); j++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("if(parts.elementAt(j).equals(a))");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("all.add(b);");
      writer.write(NEWLINE);
      writer.write("break;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return all;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      
      // "getActionWithId" method:
      writer.write("public " + CodeGeneratorUtils.getUpperCaseLeading(
      		actType.getName()) + "Action getActionWithId(int id) {");
      writer.write(NEWLINE);
      writer.write("for (int i = 0; i < actions.size(); i++) {");
      writer.write(NEWLINE);
      writer.write(CodeGeneratorUtils.getUpperCaseLeading(actType.getName()) + 
      		"Action act = actions.get(i);");
      writer.write(NEWLINE);
      writer.write("if (act.getId() == id) {");
      writer.write(NEWLINE);
      writer.write("return act;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return null;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      
      // refetchParticipants method:
    	writer.write("/*");
    	writer.write(NEWLINE);
    	writer.write("* Replaces all the participants in each action with their equivalent objects");
    	writer.write(NEWLINE);
    	writer.write("* in the current state. Calling this function solves the problem that");
    	writer.write(NEWLINE);
    	writer.write("* happens when you clone actions -- their hashtables point to participant");
    	writer.write(NEWLINE);
    	writer.write("* objects that were part of the previous, non-cloned state.");
    	writer.write(NEWLINE);
    	writer.write("* Hence, this function should be called after this object is cloned.");
    	writer.write(NEWLINE);
    	writer.write("*/");
    	writer.write(NEWLINE);
    	writer.write("public void refetchParticipants(ArtifactStateRepository artifactRep, CustomerStateRepository customerRep, EmployeeStateRepository employeeRep, ProjectStateRepository projectRep, ToolStateRepository toolRep) {");
    	writer.write(NEWLINE);
    	writer.write("for (int i = 0; i < actions.size(); i++) {");
    	writer.write(NEWLINE);
    	writer.write(CodeGeneratorUtils.getUpperCaseLeading(actType.getName()) + 
    			"Action act = actions.elementAt(i);");
    	writer.write(NEWLINE);
    	writer.write("act.refetchParticipants(artifactRep, customerRep, employeeRep, projectRep, toolRep);");
    	writer.write(CLOSED_BRACK);
    	writer.write(NEWLINE);
    	writer.write(CLOSED_BRACK);
    	writer.write(NEWLINE);

      writer.write(CLOSED_BRACK);
      writer.close();
    } catch (IOException e) {
      JOptionPane.showMessageDialog(null, ("Error writing file "
          + repFile.getPath() + ": " + e.toString()), "File IO Error",
          JOptionPane.WARNING_MESSAGE);
    }
  }
}